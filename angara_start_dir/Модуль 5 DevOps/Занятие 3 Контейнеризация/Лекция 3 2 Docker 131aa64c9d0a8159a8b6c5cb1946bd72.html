<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Лекция 3.2. Docker</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-default_background {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-default_background {
	color: inherit;
	fill: inherit;
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-transparentGray { background-color: rgba(227, 226, 224, 0); }
.select-value-color-translucentGray { background-color: rgba(0, 0, 0, 0.06); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="131aa64c-9d0a-8159-a8b6-c5cb1946bd72" class="page sans"><header><div class="page-header-icon undefined"><img class="icon" src="https://www.notion.so/icons/slideshow_gray.svg"/></div><h1 class="page-title">Лекция 3.2. Docker</h1><p class="page-description"></p></header><div class="page-body"><h1 id="131aa64c-9d0a-81e7-a1dd-f182cf36a5f4" class="">Оглавление</h1><nav id="131aa64c-9d0a-8195-9f45-faf758d91c5a" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#131aa64c-9d0a-81e7-a1dd-f182cf36a5f4">Оглавление</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#131aa64c-9d0a-8188-a093-d4afd7aba120">1. Теоретическая часть</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#131aa64c-9d0a-811e-a44b-e36247b17e3f">1.1 Что такое Docker?</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#131aa64c-9d0a-81e1-ae4d-df814346292b">1.2 История создания</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-8179-b788-e25332daf065">1.2.1 Доисторические времена - chroot и jails</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-81bc-8884-dda628aa6c71">1.2.2 Средневековье - <strong>cgroups, namespaces and LXC</strong></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-81e8-8af2-e2a06e34f950">1.2.3 Наше время - <strong>Docker</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#131aa64c-9d0a-814a-81fe-c5633e4942fc">1.3 Архитектура ядра Docker</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-81da-90af-c6aa7e89fe72">1.3.1 Docker Engine</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-8120-8430-d09eea8b3505">1.3.2 Docker-containerd</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-8178-8c7b-fa8e16c90de0">1.3.3 Docker-runc</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#131aa64c-9d0a-8147-8225-f07f037e7494">1.4 Компоненты</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-81ea-933d-fdbd9c65df76">1.4.1 Docker Daemon</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-815d-a029-fe533f068b06">1.4.2 Docker Client</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-81ec-a530-edddf6803af6">1.4.3 Образы Docker</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-8187-a50e-e34f13865d24">1.4.4 Контейнеры Docker</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-810f-9450-e27ee45332d9">1.4.5 Docker Registers</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-819e-b7a0-fa1a2afc47ff">1.4.6 Docker Hub</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#131aa64c-9d0a-818e-a5cf-d7079f0ef02d">1.5 <strong>Хранение данных в Docker</strong></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-81fc-ae9b-d9ce64e8a4ee">1.5.1 <strong>Тома (Docker volumes)</strong></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-8194-b4d5-c42b28cad17b">1.5.2 <strong>Монтирование с привязкой (bind mount)</strong></a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-81c4-b08e-de42165428ac">1.5.3 <strong>Монтирование временного каталога (tmpfs mount)</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#131aa64c-9d0a-81d7-80e0-de1b8da0bce0">1.6 Сети в Docker контейнерах</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-815a-a1d2-ee5bf4b3d579">1.6.1 Сетевые драйверы</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-8111-90e6-fd3b4bce7c3f">1.6.2 Публикация(Проброс) портов</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-8116-926a-f345f59d4b30">1.6.3 Сервисы DNS</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#131aa64c-9d0a-8146-b379-e2aa7bdf6829">1.6.4 Фильтрация пакетов и межсетевые экраны</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#131aa64c-9d0a-8136-b44d-de10339cc0b4">1.7 Dockerfile</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#131aa64c-9d0a-816a-ae3f-e8cb3476310a">1.8 Docker-compose</a></div></nav><h1 id="131aa64c-9d0a-8188-a093-d4afd7aba120" class="">1. Теоретическая часть</h1><h2 id="131aa64c-9d0a-811e-a44b-e36247b17e3f" class="">1.1 Что такое Docker?</h2><p id="131aa64c-9d0a-8157-a2bb-ce2add4a2f5c" class="">Docker — это платформа с открытым исходным кодом, которая позволяет разработчикам создавать, развертывать, запускать, обновлять и управлять контейнерами — стандартизированными исполняемыми компонентами, объединяющими исходный код приложения с библиотеками операционной системы (ОС) и зависимостями, необходимыми для запуска этого кода в любой среде.</p><p id="131aa64c-9d0a-8160-aa12-f7f043dfcf29" class="">Контейнеры упрощают разработку и доставку распределенных приложений. Они становятся все более популярными по мере того, как организации переходят на облачную разработку и гибридные мультиоблачные среды. Разработчики могут создавать контейнеры без Docker, работая напрямую с возможностями, встроенными в Linux и другие операционные системы. Но Docker делает контейнеризацию быстрее, проще и безопаснее. </p><p id="131aa64c-9d0a-8141-91a5-c38f009ec4be" class="">Docker также относится к Docker, Inc., компании, которая продает коммерческую версию Docker, а также к проекту Docker с открытым исходным кодом. В этот проект вносят свой вклад Docker, Inc. и многие другие организации и частные лица.</p><h2 id="131aa64c-9d0a-81e1-ae4d-df814346292b" class="">1.2 История создания</h2><h3 id="131aa64c-9d0a-8179-b788-e25332daf065" class="">1.2.1 Доисторические времена - chroot и jails</h3><p id="131aa64c-9d0a-81ae-97a2-c75a7ce02402" class=""><em><strong>Chroot</strong></em> впервые был представлен более 40 лет назад, в 1979 году во время разработки UNIXv7. Его единственным предназначением было изменение родительской корневой системы файлового процесса и его дочерних процессов. В нем не было ни сетевых пространств имен, ни современной изоляции процессов. В 2000 году FreeBSD <em><strong>jail</strong></em> расширили возможности chroot и добавили новые возможности. Jails имели собственные сетевые интерфейсы, со своими ip-адресами и отключенным по умолчанию <a href="https://www.baeldung.com/cs/raw-sockets">сырыми сокетами</a>. После этого они стали напоминать виртуальные машины.</p><p id="131aa64c-9d0a-812a-a618-da416b2d8c3c" class="">Сообщество Linux вскоре подключилось к развитию этой идеи, выпустив Linux-VServer в 2001 году и OpenVZ в 2005 году. Оба они представляли собой нестандартные патчи для ядра Linux, и поэтому их было относительно сложно поддерживать. Они обеспечивали достойную изоляцию сети и процессов, но не были лишены недостатков. Не помогло и то, что хостинг-провайдеры продавали эти контейнеры как легковесные виртуальные машины, что расстраивало пользователей, которым нужны были те же возможности, которые они имели с виртуальными машинами.</p><h3 id="131aa64c-9d0a-81bc-8884-dda628aa6c71" class="">1.2.2 Средневековье - <strong>cgroups, namespaces and LXC</strong></h3><p id="131aa64c-9d0a-81b2-9668-ca12aa2cd56f" class="">Пространства имен (<em><strong>namespaces</strong></em>) — функция ядра Linux, которая была разработана в 2002 году в версии ядра 2.4.19, позволяющая изолировать и виртуализировать глобальные системные ресурсы множества процессов. Пространства имен разделяют ресурсы ядра так, что процесс в одном пространстве имен не может видеть ресурсы других пространств имен. Создание почти всех частей ядра Linux с учетом пространства имен все еще является продолжающимся проектом. Наиболее важными из них являются монтирование, идентификатор процесса, доступ к сетям, межпроцессное взаимодействие и пространство имен пользователя. </p><p id="131aa64c-9d0a-8125-9e7c-f0e9d234793d" class="">Контрольные группы (<em><strong>cgroups</strong></em>) — функция ядра Linux, внедренная в 2008 году для изоляции использования ресурсов (загрузка процессора, оперативной памяти, сети и др.) группами процессов. Эта технология притерпела множество изменений за последующие года, но всегда сохраняла свою основную цель — создание стандартизированного подхода к процессу изоляции в ядре Linux. В 2013 году контрольные группы были переработаны с использованием технологии пространства имен. </p><p id="131aa64c-9d0a-816c-8e98-d2bb2c124966" class="">В 2008 году родился LXC, построенный на контрольных группах и пространствах имен. Это был первый доступный инструмент контейнеризации, работавший с исходным ядром Linux. Однако ранние версии были менее безопасными, чем его предшественники Linux-VServer и OpenVZ. Root в контейнере LXC означал root на хосте. Этого уже не было в LXC 1.0, который сделал важный шаг в обеспечении безопасности контейнеров, представив непривилегированные контейнеры с помощью пользовательских пространств имен.</p><h3 id="131aa64c-9d0a-81e8-8af2-e2a06e34f950" class="">1.2.3 Наше время - <strong>Docker</strong></h3><p id="131aa64c-9d0a-813f-9d3b-f701e146ea05" class="">Docker разработали в 2008 году. Изначально это был внутренний проект компании dotCloud, которую впоследствии была переименована в Docker Inc. В 2013 году dotCloud открыла исходный код Docker для сообщества. </p><p id="131aa64c-9d0a-816d-9d40-c3e2444e779d" class="">Ранние версии Docker представляли собой усовершенствованную обёртку LXC, а с 2015 года Docker уже использовал собственную библиотеку libcontainer, абстрагирующую виртуализационные возможности ядра Linux. Так он превратился в самостоятельную технологию. Платформа неслучайно переехала на libcontainer: гибкость и управляемость LXC-контейнеров оставляла желать лучшего. </p><p id="131aa64c-9d0a-818a-986a-cf24714a815c" class="">Популярность Docker продолжает расти, потому что его поддерживает большое сообщество.</p><figure id="131aa64c-9d0a-8130-88f1-fa8d7a1d390a" class="image"><a href="%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%203%202%20Docker%20131aa64c9d0a8159a8b6c5cb1946bd72/Untitled.png"><img style="width:1405px" src="%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%203%202%20Docker%20131aa64c9d0a8159a8b6c5cb1946bd72/Untitled.png"/></a></figure><blockquote id="131aa64c-9d0a-812a-8010-f7e0ef7122e2" class="">Goovle Trends для слова docker</blockquote><h2 id="131aa64c-9d0a-814a-81fe-c5633e4942fc" class="">1.3 Архитектура ядра Docker</h2><p id="131aa64c-9d0a-81a9-a6f5-f6de8a961a63" class="">Когда Docker был только запущен, он имел монолитную архитектуру. Теперь он разделен на следующие три различных части.</p><ol type="1" id="131aa64c-9d0a-8126-a3e3-de37921bf3be" class="numbered-list" start="1"><li>Docker Engine (dockerd)</li></ol><ol type="1" id="131aa64c-9d0a-8183-8dea-ed7db01c49d8" class="numbered-list" start="2"><li>docker-containerd (containerd)</li></ol><ol type="1" id="131aa64c-9d0a-81b5-a024-d7e78b1f69ac" class="numbered-list" start="3"><li>docker-runc</li></ol><p id="131aa64c-9d0a-8134-bab8-c4be56f0e55e" class="">Docker и другие крупные организации внесли свой вклад в создание стандартной среды выполнения контейнеров и уровней управления. Таким образом, <em><strong>Containerd</strong></em> и <em><strong>Runc</strong></em> теперь являются частью Cloud Native Foundation, в которую вносят вклад все организации.</p><figure id="131aa64c-9d0a-81d5-8065-d97f0a2e61bc" class="image"><a href="%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%203%202%20Docker%20131aa64c9d0a8159a8b6c5cb1946bd72/Untitled_(3).jpg"><img style="width:1437px" src="%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%203%202%20Docker%20131aa64c9d0a8159a8b6c5cb1946bd72/Untitled_(3).jpg"/></a></figure><h3 id="131aa64c-9d0a-81da-90af-c6aa7e89fe72" class="">1.3.1 Docker Engine</h3><p id="131aa64c-9d0a-81ac-a81f-d6521bc3d02f" class="">Docker Engine включает в себя демон Docker, интерфейс API и интерфейс командной строки Docker. Демон Docker (<em><strong>dockerd</strong></em>) работает постоянно как служба <em><strong>dockerd systemd</strong></em>. Он отвечает за создание образов докера. </p><figure id="131aa64c-9d0a-8144-bf38-f6dbfd888cca" class="image"><a href="%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%203%202%20Docker%20131aa64c9d0a8159a8b6c5cb1946bd72/Untitled_(5).jpg"><img style="width:1212px" src="%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%203%202%20Docker%20131aa64c9d0a8159a8b6c5cb1946bd72/Untitled_(5).jpg"/></a></figure><h3 id="131aa64c-9d0a-8120-8430-d09eea8b3505" class="">1.3.2 Docker-containerd</h3><p id="131aa64c-9d0a-81d7-ad32-ec78f9aca0c3" class=""><em><strong>Containerd </strong></em>— это еще одна служба системного демона, которая отвечает за загрузку образов докеров и их запуск в качестве контейнера. Он предоставляет свой API для получения инструкций от службы dockerd. </p><h3 id="131aa64c-9d0a-8178-8c7b-fa8e16c90de0" class="">1.3.3 Docker-runc</h3><p id="131aa64c-9d0a-81d9-9339-eb0452d6763e" class=""><em><strong>Runc </strong></em>— это среда выполнения контейнера, ответственная за создание пространств имен и контрольных групп, необходимых для контейнера. Затем он запускает команды контейнера внутри этих пространств имен. Среда выполнения runc реализована в соответствии со спецификацией <a href="https://github.com/opencontainers/runtime-spec?ysclid=lsur7mmx46833830580">OCI</a>.</p><h2 id="131aa64c-9d0a-8147-8225-f07f037e7494" class="">1.4 Компоненты</h2><figure id="131aa64c-9d0a-8157-8138-dd1eb283da52" class="image"><a href="%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%203%202%20Docker%20131aa64c9d0a8159a8b6c5cb1946bd72/Untitled_(6).jpg"><img style="width:1514px" src="%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%203%202%20Docker%20131aa64c9d0a8159a8b6c5cb1946bd72/Untitled_(6).jpg"/></a></figure><p id="131aa64c-9d0a-819d-af4b-dc5acc1913b6" class="">Docker имеет клиент-серверную архитектуру. За все действия, связанные с контейнерами, отвечает Docker Daemon (dockerd) или сервер.</p><p id="131aa64c-9d0a-812d-b92a-df81e5fa6d99" class="">Вы вызываете Docker-клиент, чтобы получить информацию или дать инструкции демону. Демон – это сервер, который получает запросы и возвращает ответы от клиента по протоколу HTTP. В свою очередь, он будет отправлять запросы в другие службы для отправки и  получения образов, также используя протокол HTTP. Сервер будет принимать запросы от клиента командной строки или любого, кто авторизован для подключения. </p><p id="131aa64c-9d0a-817d-8046-c8af1a1b574e" class="">Клиент Docker может находиться на том же хосте, что и демон, или присутствовать на любом другом хосте.</p><p id="131aa64c-9d0a-813e-8d00-e07e295422d1" class="">Демон также отвечает за заботу о ваших образах и контейнерах за кулисами, тогда как клиент выступает в качестве посредника между вами и интерфейсом RESTful. </p><p id="131aa64c-9d0a-8179-b412-f1bcbfb43cbe" class="">Образы (Images)  — это основные строительные блоки Docker. Он содержит библиотеки ОС, зависимости и инструменты для запуска приложения. </p><p id="131aa64c-9d0a-81c6-92b7-e915abc642f6" class="">Контейнеры Docker создаются из существующих образов. Это записываемый слой образа.</p><p id="131aa64c-9d0a-818a-98f1-f7cd0e3ce10d" class="">Частный реестр Docker  – это сервис, который хранит образы Docker. Их можно запросить у любого демона Docker, у которого есть соответствующий доступ. Этот реестр находится во внутренней сети и не является общедоступным, поэтому считается закрытым.</p><p id="131aa64c-9d0a-818b-8f4e-c2c894810ebf" class="">Docker Hub – это общедоступный реестр, управляемый Docker Inc. В интернете также могут существовать другие публичные реестры, и ваш демон Docker способен взаимодействовать с ними.</p><p id="131aa64c-9d0a-8188-a20a-e7b50fc23fb3" class="">Также в сети могут существовать другие публичные реестры Docker, к которым мы можем получить доступ и звпросить у них образы Docker.</p><h3 id="131aa64c-9d0a-81ea-933d-fdbd9c65df76" class="">1.4.1 Docker Daemon</h3><p id="131aa64c-9d0a-8181-a97b-d44fa996912a" class="">Демон Docker – это центр ваших взаимодействий с Docker, и поэтому он является лучшим местом, где вы можете начать понимать все соответствующие элементы. Он контролирует доступ к Docker на вашем компьютере, управляет состоянием контейнеров и образов, а также взаимодействует с внешним миром.</p><figure class="block-color-blue_background callout" style="white-space:pre-wrap;display:flex" id="131aa64c-9d0a-81ba-80a6-fb8e35fd2c17"><div style="font-size:1.5em"><span class="icon">🔎</span></div><div style="width:100%">Демон – это процесс, который выполняется в фоновом режиме, а  не  под непосредственным контролем пользователя. Сервер – процесс, который принимает запросы от клиента и осуществляет действия, необходимые для выполнения запросов. Демоны часто также являются серверами, принимающими запросы от клиентов для выполнения действий для них. Команда docker – это клиент, а демон<br/>Docker выступает в качестве сервера, выполняющего обработку ваших контейнеров и образов Docker.<br/></div></figure><p id="131aa64c-9d0a-81b1-9fc6-d6a05d17fdbc" class="">По умолчанию демон docker прослушивает UNIX-сокет docker.sock. Если у вас есть вариант использования удаленного доступа к API-интерфейсу Docker, вам необходимо предоставить его через порт хоста. Одним из таких вариантов использования является запуск Docker в качестве агентов Jenkins.</p><h3 id="131aa64c-9d0a-815d-a029-fe533f068b06" class="">1.4.2 Docker Client</h3><p id="131aa64c-9d0a-810e-b7d2-cf98dc2043d9" class="">Клиент Docker – самый простой компонент в архитектуре Docker. Это то, что вы запускаете, когда набираете такие команды, как docker run или docker pull на своем компьютере. Его задача – взаимодействовать с демоном Docker посредством HTTP-запросов.</p><h3 id="131aa64c-9d0a-81ec-a530-edddf6803af6" class="">1.4.3 Образы Docker</h3><p id="131aa64c-9d0a-8127-9dff-fd1aa2cb3d13" class="">Это шаблон, по которому создают контейнеры. Его часто сравнивают со слоёным пирогом: мы накладываем слой файловой системы поверх слоя базового образа и получаем неизменяемый образ. В него можно установить приложение, конфигурации и зависимости. Другие образы могут наследоваться, поэтому если положить сверху слой файлов и закоммитить, то мы получим ещё один неизменяемый образ.</p><h3 id="131aa64c-9d0a-8187-a50e-e34f13865d24" class="">1.4.4 Контейнеры Docker</h3><p id="131aa64c-9d0a-81a7-8938-fe718a1848c0" class="">Контейнер — это runtime-сущность на основе образа, приложение, которое мы развернули с помощью Docker. Можно провести такую аналогию: образ — это инсталлятор программы, а контейнер — уже запущенная программа.<br/>При развёртывании контейнера поверх файловой системы создаётся ещё один изменяемый слой. Приложение внутри контейнера может записывать туда данные или редактировать их. После удаления контейнера данные стираются, но их можно сохранить с помощью <br/><em><strong>volumes</strong></em>.</p><h3 id="131aa64c-9d0a-810f-9450-e27ee45332d9" class="">1.4.5 Docker Registers</h3><p id="131aa64c-9d0a-81c6-bf9f-f696fc101577" class="">После того как вы создали свои образы, можете поделиться ими с другими пользователями. Вот тут-то и вступает в действие концепция реестра Docker. </p><p id="131aa64c-9d0a-8180-9a5e-c9c92d4ca600" class="">Три реестра на рисунке различаются по своей доступности. Один находится в частной сети, один открыт во внешней сети, а другой общедоступен, но только для тех, кто зарегистрирован в  Docker. Все они выполняют одну и ту  же функцию с одним и тем же API, и вот откуда демон Docker знает, как обмениваться с ними информацией на взаимозаменяемой основе.</p><p id="131aa64c-9d0a-8108-9961-f6502f55dd5f" class="">Реестр Docker позволяет нескольким пользователям размещать и извлекать образы из центрального хранилища, используя RESTful API. Код реестра, как и сам Docker, – это ПО с открытым исходным кодом. Многие компании создают частные реестры для внутреннего хранения и совместного использования своих собственных образов.</p><p id="131aa64c-9d0a-8132-b800-e7007b234d20" class="">По умолчанию при установке Docker он ищет образы в Docker Hub, если вы не укажете собственный реестр в настройках Docker.</p><h3 id="131aa64c-9d0a-819e-b7a0-fa1a2afc47ff" class="">1.4.6 Docker Hub</h3><p id="131aa64c-9d0a-8140-b8e5-f120cfca3473" class="">Docker Hub – это реестр, поддерживаемый Docker Inc. Он содержит десятки тысяч образов, готовых к загрузке и запуску. Любой пользователь Docker может создать бесплатную учетную запись и хранить там общедоступные образы Docker. В дополнение к предоставленным пользователями официальные образы поддерживаются для справочных целей.</p><p id="131aa64c-9d0a-8142-afc2-efe0716a0b41" class="">Ваши образы защищены аутентификацией пользователя, и существует звездная система популярности, похожая на  ту, что есть в  GitHub. Официальные образы могут быть представлениями дистрибутивов Linux, таких как Ubuntu или CentOS, предустановленными пакетами программного обеспечения, такими как Node.js, или целыми программными стеками, такими как WordPress.</p><p id="131aa64c-9d0a-812d-afbe-e485584d5fba" class="">Другие пользователи Docker Hub смогут получить доступ ко всем вашим образам, если ваш репозиторий является общедоступным. Вы также можете создать частный реестр в Docker Hub.</p><h2 id="131aa64c-9d0a-818e-a5cf-d7079f0ef02d" class="">1.5 <strong>Хранение данных в Docker</strong></h2><p id="131aa64c-9d0a-8168-87f1-c517581b300e" class="">Одной из основных отличительных черт контейнеров считается эфемерность. Это значит, то что контейнеры могут быть остановлены, перезапущены или ликвидированы в любой период времени. В данном случае вся без исключения собранная в контейнере информация будет утрачена. Таким образом, приложения обязаны быть спроектированы таким способом, чтобы они никак не полагались на сохранение сведений в контейнере, данное зовется принципом без сохранения состояния (Stateless).</p><p id="131aa64c-9d0a-8141-80fe-f2db1622cad2" class="">Это хорошо для приложений или сервисов, которые не сохраняют результаты своей работы. Например, функции для вычисления или преобразования данных: они получили один набор данных в качестве входных данных, они преобразовали его или вычислили и вернули результат. Вот и все, вам не нужно ничего нигде сохранять.</p><p id="131aa64c-9d0a-8195-a5e6-e659b0b8c054" class="">Но не все приложения такие, и нужно сохранять много данных. Контейнеры предоставляют несколько способов сделать: <em><strong>volumes, bind mount, tmpfs mount</strong></em><strong>.</strong></p><p id="131aa64c-9d0a-81fc-9771-cc2e1398580b" class="">Независимо от того, какой тип монтирования вы выберете, данные внутри контейнера будут выглядеть одинаково. Он предоставляется либо как каталог, либо как отдельный файл в файловой системе контейнера.</p><p id="131aa64c-9d0a-811e-b224-f5dc4e65ca3e" class="">Простой способ визуализировать разницу между <em><strong>volumes(тома)</strong></em>,<em><strong> bind mount(монтирование </strong></em>с<strong> </strong>привязкой) и <em><strong>tmpfs mount</strong></em> — это подумать о том, где находятся данные на хосте Docker.</p><figure id="131aa64c-9d0a-8150-bfbf-cb5d979c2b79" class="image"><a href="%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%203%202%20Docker%20131aa64c9d0a8159a8b6c5cb1946bd72/DevOps_(1).jpg"><img style="width:1450px" src="%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F%203%202%20Docker%20131aa64c9d0a8159a8b6c5cb1946bd72/DevOps_(1).jpg"/></a></figure><p id="131aa64c-9d0a-81aa-8c25-cf961b7ee3dc" class="">Тома хранятся в части файловой системы хоста, которая управляется Docker (/var/lib/docker/volumes/ в Linux). Процессы, не относящиеся к Docker, не должны изменять эту часть файловой системы. Тома — лучший способ сохранить данные в Docker.</p><p id="131aa64c-9d0a-81f4-b993-e37db41fa0cb" class="">При монтирования с<strong> </strong>привязкой данные могут храниться где угодно в хост-системе. Это могут быть даже важные системные файлы или каталоги. Не-Docker-процессы на хосте Docker или в контейнере Docker могут изменить их в любое время.</p><p id="131aa64c-9d0a-812b-a389-ede35ba06553" class="">Монтирования tmpfs хранятся только в оперативной памяти хост-системы и никогда не записываются в файловую систему хост-системы.</p><h3 id="131aa64c-9d0a-81fc-ae9b-d9ce64e8a4ee" class="">1.5.1 <strong>Тома (Docker volumes)</strong></h3><p id="131aa64c-9d0a-811c-8ff2-eda698d619c4" class="">Тома являются предпочтительным способом сохранения данных, созданных и использованных контейнерами docker. Хотя монтирование зависит от структуры каталогов и операционной системы хост-компьютера, тома полностью контролируются docker. У томов есть несколько преимуществ по сравнению с монтированием:</p><ul id="131aa64c-9d0a-81e5-a88c-e7cad52af2dc" class="bulleted-list"><li style="list-style-type:disc">Тома легче резервировать и мигрировать, чем монтирование.</li></ul><ul id="131aa64c-9d0a-816e-a72f-f3cd815be4ad" class="bulleted-list"><li style="list-style-type:disc">Управление томами возможно с помощью команд docker CLI или docker API.</li></ul><ul id="131aa64c-9d0a-819d-b7f2-f86e2e98582f" class="bulleted-list"><li style="list-style-type:disc">Тома работают как с контейнерами Linux, так и с Windows.</li></ul><ul id="131aa64c-9d0a-81f3-a18a-d68473d1cd03" class="bulleted-list"><li style="list-style-type:disc">Возможность безопасного распределения томов между несколькими контейнерами.</li></ul><ul id="131aa64c-9d0a-814d-bd68-f8f18083ed7b" class="bulleted-list"><li style="list-style-type:disc">Драйверы томов позволяют хранить тома на удаленных хостах или у облачных провайдеров, шифровать содержимое и добавлять другие функции.</li></ul><ul id="131aa64c-9d0a-8192-b6d0-f1f9960bbf81" class="bulleted-list"><li style="list-style-type:disc">Новые тома могут быть предварительно заполнены контейнером.</li></ul><ul id="131aa64c-9d0a-812a-92f1-e7bb7d67b6e6" class="bulleted-list"><li style="list-style-type:disc">Тома на Docker Desktop обладают значительно высокой производительностью по сравнению с монтированием на Mac и Windows.</li></ul><ul id="131aa64c-9d0a-8124-95e8-ef115a04d72a" class="bulleted-list"><li style="list-style-type:disc">Тома часто являются лучшим выбором для сохранения данных, поскольку они не увеличивают размер контейнеров, использующих их, и содержимое тома существует вне жизненного цикла конкретного контейнера.</li></ul><p id="131aa64c-9d0a-81e1-9d2c-f5bfbdcfcfac" class="">Если ваш контейнер генерирует непостоянные данные о состоянии, рекомендуется использовать монтирование tmpfs, чтобы избежать постоянного хранения данных и повысить производительность контейнера, избегая записи в доступный для записи слой контейнера.</p><h3 id="131aa64c-9d0a-8194-b4d5-c42b28cad17b" class="">1.5.2 <strong>Монтирование с привязкой (bind mount)</strong></h3><p id="131aa64c-9d0a-81a8-8ce3-c14beeea6425" class="">Монтирование с<strong> </strong>привязкой существуют с первых дней существования Docker. Этот способ организации файловой системы контейнера имеет ограниченную функциональность по сравнению с томами. При использовании монтирования с<strong> </strong>привязкой<em><strong> </strong></em>файл или каталог на хост-компьютере монтируется в контейнер. На файл или каталог ссылаются по его абсолютному пути на хост-компьютере. Напротив, когда вы используете том, в каталоге хранилища Docker на хост-компьютере создается новый каталог, и Docker управляет содержимым этого каталога.</p><p id="131aa64c-9d0a-819d-a567-dd26c5715e40" class="">Файл или каталог не обязательно должен уже существовать на хосте Docker. Он создается по требованию, если он еще не существует. Монтирование с привязкой очень эффективно, но оно зависит от наличия в файловой системе хост-компьютера определенной структуры каталогов. Если вы разрабатываете новые приложения Docker, рассмотрите возможность использования вместо них именованных томов. Вы не можете использовать команды Docker CLI для прямого управления данными при монтировании с<strong> </strong>привязкой.</p><h3 id="131aa64c-9d0a-81c4-b08e-de42165428ac" class="">1.5.3 <strong>Монтирование временного каталога (tmpfs mount)</strong></h3><p id="131aa64c-9d0a-8192-aa9e-d0ecb6833d5b" class="">Тома и монтирования с<strong> </strong>привязкой позволяют обмениваться файлами между хост-компьютером и контейнером, чтобы вы могли сохранять данные даже после остановки контейнера.</p><p id="131aa64c-9d0a-81ec-975c-ed48e30952e4" class="">Если вы используете Docker в Linux, у вас есть третий вариант: монтирование tmpfs. Когда вы создаете контейнер с монтированием tmpfs, контейнер может создавать файлы вне доступного для записи слоя контейнера.</p><p id="131aa64c-9d0a-81fa-abde-cd81510d5387" class="">В отличие от томов и монтирования с<strong> </strong>привязкой, монтирование tmpfs является временным и сохраняется только в оперативной памяти хоста. Когда контейнер останавливается, монтирование tmpfs удаляется, и записанные в него файлы не сохраняются.</p><p id="131aa64c-9d0a-81f7-926f-cb1226395a64" class="">Это полезно для временного хранения конфиденциальных файлов, которые вы не хотите сохранять ни на хосте, ни на доступном для записи уровне контейнера.</p><p id="131aa64c-9d0a-81b8-86f6-fec5b1113c13" class="">Ограничения tmpfs монтирования:</p><ul id="131aa64c-9d0a-8166-9534-fbd9f7ad712c" class="bulleted-list"><li style="list-style-type:disc">В отличии от томов и монтирования с привязкой, монтирование tmpfs не позволяет установить одну точку крепления для разных контейнеров.</li></ul><ul id="131aa64c-9d0a-816e-a78c-d027c36a88aa" class="bulleted-list"><li style="list-style-type:disc">Доступно только в том случае, если вы используете Docker на Linux.</li></ul><ul id="131aa64c-9d0a-8131-a23c-f10e583ff5a7" class="bulleted-list"><li style="list-style-type:disc">Неаккуратная установка прав доступа к tmpfs может привести к очистке информации после перезапуска контейнера.</li></ul><h2 id="131aa64c-9d0a-81d7-80e0-de1b8da0bce0" class="">1.6 Сети в Docker контейнерах</h2><p id="131aa64c-9d0a-8151-9189-f940f7bb4286" class="">Под сетью контейнеров подразумевается способность контейнеров подключаться и взаимодействовать друг с другом или с рабочими нагрузками, не относящимися к Docker.</p><p id="131aa64c-9d0a-81bc-b237-c8997630242c" class="">В контейнерах по умолчанию включена сеть, и они могут устанавливать исходящие соединения. Контейнер не имеет информации о том, к какому типу сети он подключен, а также о том, являются ли его одноранговые узлы также рабочими нагрузками Docker или нет. Контейнер видит только сетевой интерфейс с IP-адресом, шлюзом, таблицей маршрутизации, службами DNS и другими сетевыми деталями. Только контейнер не использует сетевой драйвер none.</p><p id="131aa64c-9d0a-8188-b711-dde06033c0ec" class="">Вы можете создавать собственные пользовательские сети и подключать несколько контейнеров к одной сети. После подключения к определяемой пользователем сети контейнеры могут взаимодействовать друг с другом, используя IP-адреса контейнеров или имена контейнеров.</p><h3 id="131aa64c-9d0a-815a-a1d2-ee5bf4b3d579" class="">1.6.1 Сетевые драйверы</h3><p id="131aa64c-9d0a-81f8-9427-db53a488474c" class="">Сетеввая подсистема Docker основыввается на использовании</p><ul id="131aa64c-9d0a-8132-9635-f1ad2d8f54ff" class="bulleted-list"><li style="list-style-type:disc">Bridge network driver.<p id="131aa64c-9d0a-81e1-9caa-c8f731dd85fc" class="">С точки зрения сети мостовая сеть представляет собой устройство канального уровня, которое перенаправляет трафик между сегментами сети. Мост может быть аппаратным или программным устройством, работающим в ядре хост-машины.</p><p id="131aa64c-9d0a-81e3-9306-caf9be0e00c9" class="">С точки зрения Docker, мостовая сеть использует программный мост, который позволяет контейнерам, подключенным к одной и той же мостовой сети, взаимодействовать, обеспечивая при этом изоляцию от контейнеров, которые не подключены к этой мостовой сети. Драйвер моста Docker автоматически устанавливает правила на хост-компьютере, чтобы контейнеры в разных сетях мостов не могли напрямую взаимодействовать друг с другом.</p><p id="131aa64c-9d0a-8121-bc3b-cf769c26bf7f" class="">Сети мостов применяются к контейнерам, работающим на одном хосте демона Docker. Для связи между контейнерами, работающими на разных хостах демона Docker, вы можете управлять маршрутизацией на уровне ОС или использовать оверлейную сеть.</p><p id="131aa64c-9d0a-8100-8e4a-c0444a6c7aca" class="">Когда вы запускаете Docker, сеть мостов по умолчанию (также называемая мостом) создается автоматически, и вновь запущенные контейнеры подключаются к ней, если не указано иное. Вы также можете создавать пользовательские сети мостов. Мостовые сети, определяемые пользователем, превосходят мостовую сеть по умолчанию.</p><p id="131aa64c-9d0a-813b-b420-d9e849a912cc" class=""><strong>Различия между определяемыми пользователем мостами и мостом по умолчанию</strong></p><ul id="131aa64c-9d0a-810b-b56c-f1745c11ac49" class="bulleted-list"><li style="list-style-type:circle">Пользовательские мосты обеспечивают автоматическое разрешение DNS между контейнерами.<p id="131aa64c-9d0a-810a-bf67-e0297fba17b5" class="">Контейнеры в мостовой сети по умолчанию могут обращаться друг к другу только по IP-адресам, если только вы не используете опцию --link, которая считается устаревшей. В определяемой пользователем мостовой сети контейнеры могут разрешать друг друга по имени или псевдониму.</p></li></ul><ul id="131aa64c-9d0a-8191-be1b-fdca35d4b3bc" class="bulleted-list"><li style="list-style-type:circle">Пользовательские мосты обеспечивают лучшую изоляцию.<p id="131aa64c-9d0a-8123-b7d4-e9f9ac00d5c7" class="">Все контейнеры подключаются к мостовой сети по умолчанию. Это может быть рискованно, поскольку несвязанные стеки/сервисы/контейнеры могут взаимодействовать друг с другом.</p></li></ul><ul id="131aa64c-9d0a-8181-a3b7-eaea5eafdc60" class="bulleted-list"><li style="list-style-type:circle">Каждая определяемая пользователем сеть создает настраиваемый мост.<p id="131aa64c-9d0a-8179-94d0-e1f91df4f976" class="">Если ваши контейнеры используют мостовую сеть по умолчанию, вы можете настроить ее, но все контейнеры будут использовать одни и те же настройки, такие как MTU и правила iptables. Кроме того, настройка мостовой сети по умолчанию происходит вне самого Docker и требует перезапуска Docker.</p></li></ul></li></ul><ul id="131aa64c-9d0a-8180-a58c-f802b91e2fd6" class="bulleted-list"><li style="list-style-type:disc">Overlay network driver.<p id="131aa64c-9d0a-8129-afdc-e69bff42a788" class="">Драйвер оверлейной сети создает распределенную сеть между несколькими хостами демона Docker. Эта сеть располагается поверх (перекрывает) сетей, специфичных для хоста, позволяя контейнерам, подключенным к ней, безопасно взаимодействовать при включенном шифровании. Docker прозрачно обрабатывает маршрутизацию каждого пакета к правильному хосту демона Docker и к правильному контейнеру назначения и обратно.</p><p id="131aa64c-9d0a-81e8-b060-ca151b259d7f" class="">Вы можете создавать пользовательские оверлейные сети точно так же, как вы можете создавать пользовательские мостовые сети. Сервисы или контейнеры могут быть подключены к более чем одной сети одновременно. Службы или контейнеры могут взаимодействовать только между сетями, к которым каждый из них подключен.</p><p id="131aa64c-9d0a-8196-b050-dedb74d117d2" class="">Оверлейные сети часто используются для создания соединения между сервисами Swarm, но вы также можете использовать их для подключения автономных контейнеров, работающих на разных хостах. При использовании автономных контейнеров по-прежнему необходимо использовать режим Swarm для установления соединения между хостами.</p></li></ul><ul id="131aa64c-9d0a-8128-811e-ea43b33cdade" class="bulleted-list"><li style="list-style-type:disc">Host network driver.<p id="131aa64c-9d0a-818e-9556-f3b685298f34" class="">Если вы используете режим сети хоста для контейнера, сетевой стек этого контейнера не изолирован от хоста Docker (контейнер использует сетевое пространство имен хоста), и контейнеру не выделяется собственный IP-адрес. Например, если вы запускаете контейнер, который привязывается к порту 80, и используете сеть хоста, приложение контейнера будет доступно через порт 80 по IP-адресу хоста.</p></li></ul><ul id="131aa64c-9d0a-8121-9e5f-d0e87bf3db08" class="bulleted-list"><li style="list-style-type:disc">IPvlan network driver.<p id="131aa64c-9d0a-8165-83e5-cc27434067a5" class="">Драйвер IPvlan предоставляет пользователям полный контроль над адресацией IPv4 и IPv6. Драйвер VLAN построен на основе этого, предоставляя операторам полный контроль над маркировкой VLAN уровня 2 и даже маршрутизацией IPvlan L3 для пользователей, заинтересованных в базовой сетевой интеграции. Для развертываний наложения, которые абстрагируют физические ограничения, см. драйвер наложения с несколькими хостами.</p><p id="131aa64c-9d0a-81aa-8442-c1a1fcc2bd5e" class="">IPvlan — это новый поворот в проверенной и надежной технике виртуализации сети. Реализации Linux чрезвычайно легки, поскольку вместо использования традиционного моста Linux для изоляции они связаны с интерфейсом или субинтерфейсом Ethernet Linux для обеспечения разделения между сетями и подключения к физической сети.</p><p id="131aa64c-9d0a-81ae-b2f2-fda6e68f01db" class="">IPvlan предлагает ряд уникальных функций и много возможностей для дальнейших инноваций в различных режимах. Двумя преимуществами этих подходов являются положительное влияние на производительность при обходе моста Linux и простота использования меньшего количества движущихся частей. Удаление моста, который традиционно находится между сетевым адаптером хоста Docker и интерфейсом контейнера, оставляет простую настройку, состоящую из интерфейсов контейнера, подключенных непосредственно к интерфейсу хоста Docker. К этому результату легко получить доступ для внешних служб, поскольку в этих сценариях нет необходимости в сопоставлении портов.</p></li></ul><ul id="131aa64c-9d0a-8159-ab22-de23ef7c29e5" class="bulleted-list"><li style="list-style-type:disc">Macvlan network driver.<p id="131aa64c-9d0a-8149-9e31-f7ab6c73e433" class="">Некоторые приложения, особенно устаревшие приложения или приложения, отслеживающие сетевой трафик, ожидают прямого подключения к физической сети. В такой ситуации вы можете использовать сетевой драйвер macvlan, чтобы назначить MAC-адрес виртуальному сетевому интерфейсу каждого контейнера, делая его похожим на физический сетевой интерфейс, напрямую подключенный к физической сети. В этом случае вам необходимо назначить физический интерфейс на вашем хосте Docker, который будет использоваться для Macvlan, а также подсеть и шлюз сети. Вы даже можете изолировать свои сети Macvlan, используя разные физические сетевые интерфейсы.</p><p id="131aa64c-9d0a-8141-aee3-fd8217cea7f2" class="">Имейте в виду следующее:</p><ul id="131aa64c-9d0a-8133-8a53-ccfae01e7103" class="bulleted-list"><li style="list-style-type:circle">Вы можете непреднамеренно ухудшить качество своей сети из-за нехватки IP-адресов или «распространения VLAN» — ситуации, которая возникает, когда в вашей сети имеется недопустимо большое количество уникальных MAC-адресов.</li></ul><ul id="131aa64c-9d0a-817a-805c-d030f8f5e8d2" class="bulleted-list"><li style="list-style-type:circle">Ваше сетевое оборудование должно поддерживать «неразборчивый режим», когда одному физическому интерфейсу может быть назначено несколько MAC-адресов.</li></ul><ul id="131aa64c-9d0a-81c2-ba1d-cd17d2fefb8d" class="bulleted-list"><li style="list-style-type:circle">Если ваше приложение может работать с использованием моста (на одном хосте Docker) или оверлея (для взаимодействия между несколькими хостами Docker), эти решения могут быть лучше в долгосрочной перспективе.</li></ul></li></ul><ul id="131aa64c-9d0a-818e-81d0-d29074f0b4f0" class="bulleted-list"><li style="list-style-type:disc">None network driver. <p id="131aa64c-9d0a-81ba-b1bb-c7a355a638cc" class="">Если вы хотите полностью изолировать сетевой стек контейнера, вы можете использовать флаг <code>--network none</code> при запуске контейнера. Внутри контейнера создается только устройство обратной связи (loopback interface).</p></li></ul><p id="131aa64c-9d0a-8150-973c-e39bc519b5d5" class="">Сравнение сетевых драйверов.</p><ul id="131aa64c-9d0a-8102-9ec3-db3c24e1da13" class="bulleted-list"><li style="list-style-type:disc">Мостовая сеть по умолчанию хороша для запуска контейнеров, которым не требуются специальные сетевые возможности.</li></ul><ul id="131aa64c-9d0a-8192-a0e9-c85ce2ec9bf5" class="bulleted-list"><li style="list-style-type:disc">Пользовательские мостовые сети позволяют контейнерам на одном хосте Docker взаимодействовать друг с другом. Пользовательская сеть обычно определяет изолированную сеть для нескольких контейнеров, принадлежащих общему проекту или компоненту.</li></ul><ul id="131aa64c-9d0a-8145-a44e-cb3f02e47849" class="bulleted-list"><li style="list-style-type:disc">Хост-сеть разделяет сеть хоста с контейнером. Когда вы используете этот драйвер, сеть контейнера не изолирована от хоста.</li></ul><ul id="131aa64c-9d0a-812f-b2a1-eb10ee5648a5" class="bulleted-list"><li style="list-style-type:disc">Оверлейные сети лучше всего подходят, когда вам нужны контейнеры, работающие на разных хостах Docker, для связи или когда несколько приложений работают вместе с помощью сервисов Swarm.</li></ul><ul id="131aa64c-9d0a-817b-acf2-c323cbc9d453" class="bulleted-list"><li style="list-style-type:disc">Сети Macvlan лучше всего подходят, когда вы переходите с установки виртуальной машины или хотите, чтобы ваши контейнеры выглядели как физические хосты в вашей сети, каждый из которых имеет уникальный MAC-адрес.</li></ul><ul id="131aa64c-9d0a-81b6-ba47-da9fb8d1e4d5" class="bulleted-list"><li style="list-style-type:disc">IPvlan похож на Macvlan, но не назначает контейнерам уникальные MAC-адреса. Рассмотрите возможность использования IPvlan, когда существует ограничение на количество MAC-адресов, которые можно назначить сетевому интерфейсу или порту.</li></ul><h3 id="131aa64c-9d0a-8111-90e6-fd3b4bce7c3f" class="">1.6.2 Публикация(Проброс) портов</h3><p id="131aa64c-9d0a-8136-b349-ebf835c120f0" class="">Под публикацией портов стоит понимать тот случай, когда вам необходимо позволить к приложению, запущенному в контейнере Docker, подключаться извне. </p><p id="131aa64c-9d0a-8195-a5bb-d45f5c93ff3e" class="">По умолчанию, когда вы создаете или запускаете контейнер с помощью <code>docker create</code> или <code>docker run</code>, контейнер не раскрывает ни один из своих портов внешнему миру. Используйте флаг <code>--publish</code> или <code>-p,</code> чтобы сделать порт доступным для служб за пределами Docker. Это создает правило брандмауэра на хосте, сопоставляющее порт контейнера порту хоста Docker с внешним миром. </p><p id="131aa64c-9d0a-81b9-aa48-f53083c19670" class="">Публикация портов контейнеров по умолчанию небезопасна. Это означает, что когда вы публикуете порты контейнера, он становится доступен не только хосту Docker, но и внешнему миру.</p><p id="131aa64c-9d0a-8198-a6e7-cfed70f1e1ed" class="">Вот некоторые примеры:</p><table id="131aa64c-9d0a-81c2-8cce-d98f33730fff" class="simple-table"><tbody><tr id="131aa64c-9d0a-81d3-a369-e7c22a83bed8"><td id="IWXs" class="" style="width:224.21875px">Флаг</td><td id="GJ`t" class="" style="width:471px">Описание</td></tr><tr id="131aa64c-9d0a-812e-b8d4-f95de41ddfc0"><td id="IWXs" class="" style="width:224.21875px">-p 8080:80</td><td id="GJ`t" class="" style="width:471px">Сопоставление порта 8080 на хосте Docker с TCP-портом 80 в контейнере.</td></tr><tr id="131aa64c-9d0a-81d3-b8db-ddfe502a7592"><td id="IWXs" class="" style="width:224.21875px">-p 192.168.1.100:8080:80</td><td id="GJ`t" class="" style="width:471px">Сопоставление порта 8080 на IP-адресе хоста Docker 192.168.1.100 с TCP-портом 80 в контейнере.</td></tr><tr id="131aa64c-9d0a-81c3-baa4-e73fe72d3ad8"><td id="IWXs" class="" style="width:224.21875px">-p 8080:80/udp</td><td id="GJ`t" class="" style="width:471px">Сопоставление порта 8080 на хосте Docker с портом UDP 80 в контейнере.</td></tr><tr id="131aa64c-9d0a-818b-841c-d501bc2aceb7"><td id="IWXs" class="" style="width:224.21875px">-p 8080:80/tcp -p 8080:80/udp</td><td id="GJ`t" class="" style="width:471px">Сопоставление порта TCP 8080 на хосте  Docker с портом TCP 80 в контейнере и сопоставление порта UDP 8080 на хосте Docker с портом UDP 80 в контейнере.</td></tr></tbody></table><p id="131aa64c-9d0a-8138-89c7-e45a65083ffa" class="">Если вы включите IP-адрес локального хоста (127.0.0.1) в флаг публикации, только хост Docker сможет получить доступ к порту опубликованного контейнера.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="131aa64c-9d0a-81a0-b10a-e2b3c8dfc8d2" class="code"><code class="language-Bash">docker run -p 127.0.0.1:8080:80 nginx</code></pre><h3 id="131aa64c-9d0a-8116-926a-f345f59d4b30" class="">1.6.3 Сервисы DNS</h3><p id="131aa64c-9d0a-8120-a710-d154ce77b2d3" class="">По умолчанию контейнеры наследуют настройки DNS, определенные в файле конфигурации /etc/resolv.conf. Контейнеры, подключающиеся к мостовой сети по умолчанию, получают копию этого файла. Контейнеры, подключаемые к пользовательской сети, используют встроенный DNS-сервер Docker. Встроенный DNS-сервер перенаправляет внешние запросы DNS на DNS-серверы, настроенные на хосте. </p><p id="131aa64c-9d0a-810a-9035-c366f610e2c6" class="">Вы можете настроить разрешение DNS для каждого контейнера, используя флаги для команды <code>docker run</code> или <code>docker create</code>, используемой для запуска контейнера.</p><p id="131aa64c-9d0a-81aa-a0a6-cb3806910b54" class="">В следующей таблице описаны доступные флаги запуска Docker, связанные с конфигурацией DNS.</p><table id="131aa64c-9d0a-812b-a289-dedc2693d298" class="simple-table"><tbody><tr id="131aa64c-9d0a-8194-ac93-f05fcfd0acd7"><td id="|]}~" class="">Флаг</td><td id="yARu" class="" style="width:579px">Описание</td></tr><tr id="131aa64c-9d0a-8101-bcab-c9f3c747d11b"><td id="|]}~" class="">--dns</td><td id="yARu" class="" style="width:579px">IP-адрес DNS-сервера. Чтобы указать несколько DNS-серверов, используйте несколько флагов --dns. Если контейнер не может связаться ни с одним из указанных вами IP-адресов, он использует общедоступный DNS-сервер Google по адресу 8.8.8.8. Это позволяет контейнерам разрешать интернет-домены.</td></tr><tr id="131aa64c-9d0a-81cb-8df1-c2d2a6ddbe3c"><td id="|]}~" class="">--dns-search</td><td id="yARu" class="" style="width:579px">Домен поиска DNS для поиска неполных имен хостов. Чтобы указать несколько префиксов поиска DNS, используйте несколько флагов --dns-search.</td></tr><tr id="131aa64c-9d0a-811a-8c97-f3a7cd13a82d"><td id="|]}~" class="">--dns-opt</td><td id="yARu" class="" style="width:579px">Пара ключ-значение, представляющая параметр DNS и его значение. Допустимые параметры смотрите в документации вашей операционной системы для resolv.conf.</td></tr><tr id="131aa64c-9d0a-8106-b5b1-ffe805a19161"><td id="|]}~" class="">--hostname</td><td id="yARu" class="" style="width:579px">Имя хоста, которое контейнер использует для себя. По умолчанию используется идентификатор контейнера, если он не указан.</td></tr></tbody></table><h3 id="131aa64c-9d0a-8146-b379-e2aa7bdf6829" class="">1.6.4 Фильтрация пакетов и межсетевые экраны</h3><p id="131aa64c-9d0a-8141-bb92-f59f7fb90809" class="">В Linux Docker манипулирует правилами iptables для обеспечения сетевой изоляции. Хотя это деталь реализации, и вам не следует изменять правила, которые Docker вставляет в ваши политики iptables, это имеет некоторые последствия для того, что вам нужно делать, если вы хотите иметь свои собственные политики в дополнение к тем, которые управляются Docker.</p><p id="131aa64c-9d0a-81a4-a4bb-ccae982f227c" class="">Если вы используете Docker на хосте, подключенном к Интернету, вам, вероятно, понадобится политика iptables, предотвращающая несанкционированный доступ к контейнерам или другим службам, работающим на вашем хосте. </p><p id="131aa64c-9d0a-814d-b53b-e789650f6d91" class="">Docker устанавливает две собственные цепочки iptables с именами DOCKER-USER и DOCKER и гарантирует, что входящие пакеты всегда сначала проверяются этими двумя цепочками. Эти сети являются частью сети FORWARD.</p><p id="131aa64c-9d0a-81dd-bd75-e0223f3213bb" class="">Все правила iptables Docker добавляются в цепочку DOCKER. Не изменяйте эту цепочку вручную. Если вам нужно добавить правила, которые загружаются раньше правил Docker, добавьте их в цепочку DOCKER-USER. Эти правила применяются до того, как Docker автоматически создаст какие-либо правила.</p><p id="131aa64c-9d0a-8143-9bbc-c43c9750b8ba" class="">Другие правила, добавленные в цепочку FORWARD вручную или с помощью другого брандмауэра на основе iptables, оцениваются после цепочек DOCKER-USER и DOCKER. Это означает, что если вы публикуете порт через Docker, этот порт будет проброшен независимо от того, какие правила настроены в вашем брандмауэре. Если вы хотите, чтобы правила применялись даже при публикации порта через Docker, вам необходимо добавить эти правила в цепочку DOCKER-USER.</p><p id="131aa64c-9d0a-8152-a2f9-d31b5dc1ddc6" class="">Когда пакеты поступают в цепочку DOCKER-USER, они уже прошли фильтр трансляции сетевых адресов назначения (DNAT). Это означает, что используемые вами флаги iptables могут соответствовать только внутренним IP-адресам и портам контейнеров.</p><h2 id="131aa64c-9d0a-8136-b44d-de10339cc0b4" class="">1.7 Dockerfile</h2><p id="131aa64c-9d0a-8133-8100-ee36bfd8506b" class="">Dockerfile — это простой текстовый файл, в котором содержится список команд Докер-клиента. Это простой способ автоматизировать процесс создания образа. Самое классное, что команды в Dockerfile <em>почти</em> идентичны своим аналогам в Linux. Это значит, что в принципе не нужно изучать никакой новый синтаксис чтобы начать работать с докерфайлами.</p><p id="131aa64c-9d0a-81bb-b8f0-f7e679bbaa93" class="">Инструкции Dockerfile</p><ol type="1" id="131aa64c-9d0a-8143-b187-d2daf995e5d4" class="numbered-list" start="1"><li><code>FROM</code> — задаёт базовый (родительский) образ.</li></ol><ol type="1" id="131aa64c-9d0a-815e-abc3-d1be75faa68a" class="numbered-list" start="2"><li><code>LABEL</code> — описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.</li></ol><ol type="1" id="131aa64c-9d0a-8145-9890-c761144ce4d6" class="numbered-list" start="3"><li><code>ENV</code> — устанавливает постоянные переменные среды.</li></ol><ol type="1" id="131aa64c-9d0a-8120-b5f5-c3ccb0c83f7c" class="numbered-list" start="4"><li><code>RUN</code> — выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.</li></ol><ol type="1" id="131aa64c-9d0a-81e9-8d40-dee32126e8ff" class="numbered-list" start="5"><li><code>COPY</code> — копирует в контейнер файлы и папки.</li></ol><ol type="1" id="131aa64c-9d0a-81ae-8df2-ef76a6e9fa91" class="numbered-list" start="6"><li><code>ADD</code> — копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы.</li></ol><ol type="1" id="131aa64c-9d0a-815f-a3fb-d3be390c942c" class="numbered-list" start="7"><li><code>CMD</code> — описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция <code>CMD</code>.</li></ol><ol type="1" id="131aa64c-9d0a-810e-b0c0-d185de32871b" class="numbered-list" start="8"><li><code>WORKDIR</code> — задаёт рабочую директорию для следующей инструкции.</li></ol><ol type="1" id="131aa64c-9d0a-8172-a8ec-e5637cb25595" class="numbered-list" start="9"><li><code>ARG</code> — задаёт переменные для передачи Docker во время сборки образа.</li></ol><ol type="1" id="131aa64c-9d0a-8191-ad96-d3166175ac83" class="numbered-list" start="10"><li><code>ENTRYPOINT</code> — предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются.</li></ol><ol type="1" id="131aa64c-9d0a-8147-ac60-d6684980c01c" class="numbered-list" start="11"><li><code>EXPOSE</code> — указывает на необходимость открыть порт.</li></ol><ol type="1" id="131aa64c-9d0a-81ca-9020-f77e25ac313a" class="numbered-list" start="12"><li><code>VOLUME</code> — создаёт точку монтирования для работы с постоянным хранилищем.</li></ol><h2 id="131aa64c-9d0a-816a-ae3f-e8cb3476310a" class="">1.8 Docker-compose</h2><p id="131aa64c-9d0a-81ea-b930-edd4d10032a3" class="">Docker Compose — это инструмент для определения и запуска многоконтейнерных приложений. Это ключ к упрощению и эффективности разработки и развертывания.</p><p id="131aa64c-9d0a-813f-931a-cb02aecaf92a" class="">Compose упрощает управление всем стеком приложений, упрощая управление службами, сетями и томами в одном понятном файле конфигурации YAML. Затем с помощью одной команды вы создаете и запускаете все службы из вашего файла конфигурации.</p><p id="131aa64c-9d0a-8158-8df1-e026a2eef69e" class="">Сочинение работает во всех средах; производство, постановка, разработка, тестирование, а также рабочие процессы CI. Он также имеет команды для управления всем жизненным циклом вашего приложения:</p><ul id="131aa64c-9d0a-818d-a206-ee8886127929" class="bulleted-list"><li style="list-style-type:disc">Запуск, остановка и восстановление служб</li></ul><ul id="131aa64c-9d0a-8122-adb1-e8c091b47661" class="bulleted-list"><li style="list-style-type:disc">Просмотр состояния запущенных служб</li></ul><ul id="131aa64c-9d0a-81f2-91a8-e4ce33329f74" class="bulleted-list"><li style="list-style-type:disc">Потоковая передача данных журнала запущенных служб</li></ul><ul id="131aa64c-9d0a-81af-9591-d1c0104b5383" class="bulleted-list"><li style="list-style-type:disc">Запуск одноразовой команды для службы</li></ul></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>